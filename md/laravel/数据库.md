 #### 数据库
 ###### 数据库:配置(env),支持常用查询,原生sql语句,事务

  ----
  
 ###### 快速入门:
 * Laravel 能使用原生 SQL、流畅的查询构造器 和 Eloquent ORM
 * Laravel 支持四种数据库:MySQL,PostgreSQL,SQLite,SQL Server
 * 读写分离:有时候你希望 SELECT 语句使用一个数据库连接，而 INSERT，UPDATE，和 DELETE 语句使用另一个数据库连接
 * 使用多个数据库连接


  ###### 运行原生 SQL 查询:select,update,insert,delete,statement;
  * select查询:返回对象数组,对象是StdClass,参数绑定两种形式:对应位置和命名绑定  
  
  ```
  $users = DB::select('select * from users where active = ?', [1]);
  
  $results = DB::select('select * from users where id = :id', ['id' => 1]);
  
  使用结果:
  foreach ($users as $user) {
    echo $user->name;
  }
  ```
  
  
  
  * 运行插入语句:参数绑定同查询:对应和绑定

	```
	DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);
	```

* 运行更新语句:返回改变的行数

	```
	$affected = DB::update('update users set votes = 100 where name = ?', ['John']);
	```

* 运行删除语句:delete返回受该语句影响的行数：
* 
```
$deleted = DB::delete('delete from users');
```
	 
* 运行普通语句statement:不反悔任何数据 DB::statement('drop table users');
 
	 
##### 监听查询事件:listen
##### 数据库事务:DB facade 的事务方法同样适用于 查询构造器 和 Eloquent ORM.
* 一般用法
```
	DB::transaction(function () {
	DB::table('users')->update(['votes' => 1]);

	DB::table('posts')->delete();
	});
```
 
* 数据库死锁:方法接受一个可选的第二个参数 ，该参数用来表示事务发生死锁时重复执行的次数。一旦定义的次数尝试完毕，就会抛出一个异常：
```
DB::transaction(function () {
    DB::table('users')->update(['votes' => 1]);

    DB::table('posts')->delete();
}, 5);
```

* 手动数据库事务

```
DB::beginTransaction();

DB::rollBack();

DB::commit();

```
 
  ---

#### 查询构造器
###### 查询构造器为创建和运行数据库查询提供了一个方便的接口;  
###### 查询构造器使用 PDO 参数绑定来保护您的应用程序免受 SQL 注入攻击

* 从一个数据表中获取所有行  $users = DB::table('users')->get();
* 从数据表中获取单行或单列 

```
$user = DB::table('users')->where('name', 'John')->first();//单挑记录
$email = DB::table('users')->where('name', 'John')->value('email');//单个值
```
 
 
* 获取一列的值 $titles = DB::table('roles')->pluck('title'); 所有title select title from ***;
* 你还可以在返回的集合中指定字段的自定义键值：$roles = DB::table('roles')->pluck('title', 'name'); select as ;
* 分块结果  我们可以将全部 users 表数据切割成一次处理 100 条记录的一小块

```
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    foreach ($users as $user) {
        //
    }
});

可以通过在 闭包 中返回 false 来终止继续获取分块结果
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    // Process the records...

    return false;
});

在分块更新记录时，最好使用 chunkById 方法。 此方法将根据记录的主键自动对结果进行分页
在块的回调里面更新或删除记录时，对主键或外键的任何更改都可能影响块查询。 这可能会导致记录没有包含在分块结果中。
DB::table('users')->where('active', false)
    ->chunkById(100, function ($users) {
        foreach ($users as $user) {
            DB::table('users')
                ->where('id', $user->id)
                ->update(['active' => true]);
        }
    });


```

* 聚合 count, max，min， avg，还有 sum 

```
$users = DB::table('users')->count();

$price = DB::table('orders')->max('price');

和其他查询条件配合
$price = DB::table('orders')
                ->where('finalized', 1)
                ->avg('price');

```

* 判断记录是否存在  

```
return DB::table('orders')->where('finalized', 1)->exists();
return DB::table('orders')->where('finalized', 1)->doesntExist();
```

* 指定一个select语句

```
$users = DB::table('users')->select('name', 'email as user_email')->get();


$users = DB::table('users')->distinct()->get();distinct强制结果唯一



如果你已经有了一个查询构造器实例，并且希望在现有的查询语句中加入一个字段,addselect
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();


```

* 使用原生表达式DB::raw 


```
$users = DB::table('users')
                     ->select(DB::raw('count(*) as user_count, status'))
                     ->where('status', '<>', 1)
                     ->groupBy('status')
                     ->get();
注:原生表达式将会被当做字符串注入到查询中，因此你应该小心使用，避免创建 SQL 注入的漏洞					 
```

* 原生方法


 
 * where
 * \DB::table("ssr_url")->wherebetween("id),[10,15];
 * whereIn("id",[2,3,4,5,6]);
 * whereNotIn("id",[2,3,4,5,6]);
 * whereNotBetween("id",[10,100]);
 *  whereNull('updated_at')
 *  whereNotNull('updated_at')

 count(),max("time").min("time"),avg("time"),sum("time"); 
 
 构造器:select count(*) tot from user
 
 
 
 
 
 
 
 ---
 
 分页 
 
 ---
 
 数据库迁移
 
 ---
 
 数据填充 
 
 ---
 
 Redis
 
 ---